<! DOCTYPE html>
<html>
	<head>

	</head>
	<script src="https://code.jquery.com/jquery-3.3.1.min.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest"></script>

    <body onload="init()">
        <canvas id="can" width="400" height="400" style="position:absolute;top:10%;left:10%;border:2px solid;"></canvas>
    
	<p id = "prediction-text" style = "position:absolute; top:90%; left: 15%">predictions: </p>
		<button id="predict-button" class="btn btn-dark" style = "position:absolute; top:80%; left: 15%">Predict</button>
		<input type = "button" value = "Clear" size= "25" onclick="erase()" style = "position:absolute; top:80%; left: 10%"/>

    </body>
    <script type="text/javascript">
		var canvas, ctx, isDragging = false;
		var	previousX = 0;
		var previousY = 0;
		var currentX = 0;
		var currentY = 0,
			dot_flag = false;

		var x = "black";
		// variable for how think the line is
		var lineThickness = 3;
	   
		function init() {
			canvas = document.getElementById('can');
			ctx = canvas.getContext("2d");
			w = canvas.width;
			h = canvas.height;
	   
			canvas.addEventListener("mousemove", function (e) {
				findxy('move', e)
			}, false);
			canvas.addEventListener("mousedown", function (e) {
				findxy('down', e)
			}, false);
			canvas.addEventListener("mouseup", function (e) {
				findxy('up', e)
			}, false);
			canvas.addEventListener("mouseout", function (e) {
				findxy('out', e)
			}, false);
		}
	   
		// draw the line
		function draw() {
			ctx.beginPath();
			ctx.moveTo(previousX, previousY);
			ctx.lineTo(currentX, currentY);
			ctx.strokeStyle = x;
			ctx.lineWidth = lineThickness;
			ctx.stroke();
			ctx.closePath();
		}
	   
		//get mouse coordinates relative to the canvas
		function findxy(res, e) {
			if (res == 'down') {
				previousX = currentX;
				previousY = currentY;
				currentX = e.clientX - canvas.offsetLeft;
				currentY = e.clientY - canvas.offsetTop;
	   
				isDragging = true;
				dot_flag = true;
				if (dot_flag) {
					ctx.beginPath();
					ctx.fillStyle = x;
					ctx.fillRect(currentX, currentY, 2, 2);
					ctx.closePath();
					dot_flag = false;
				}
			}
			if (res == 'up' || res == "out") {
				isDragging = false;
			}
			if (res == 'move') {
				if (isDragging) {
					previousX = currentX;
					previousY = currentY;
					currentX = e.clientX - canvas.offsetLeft;
					currentY = e.clientY - canvas.offsetTop;
					draw();
				}
			}
		}
		
	$("#predict-button").click(async function () {
		// get image data from canvas
		console.log("in predict function")
		var imageData = canvas.toDataURL();
	
		// preprocess canvas
		let tensor = preprocessCanvas(canvas);
	
		// make predictions on the preprocessed image tensor
		let predictions = await model.predict(tensor).data();
	
		// get the model's prediction results
		let results = Array.from(predictions);
	
		displayLabel(results)
		// display the predictions in chart
		console.log(results)
	});
		
		function erase()
		{
			console.log("erase button clicked");
			ctx.clearRect(0, 0, w, h);

		}

		async function loadModel() {
			console.log("in load model function")
			// clear the model variable
			model = undefined; 
			// load the model using a HTTPS request (where you have stored your model files)
			model = await tf.loadLayersModel("/models/model.json");
		}
 
		loadModel();

		function preprocessCanvas(image) {
			// resize the input image to target size of (1, 28, 28)
			let tensor = tf.browser.fromPixels(image)
				.resizeNearestNeighbor([28, 28])
				.mean(2)
				.expandDims(2)
				.expandDims()
				.toFloat();
			return tensor.div(255.0);
		}

		function displayLabel(data) {
    var max = data[0];
    var maxIndex = 0;
 
    for (var i = 1; i < data.length; i++) {
        if (data[i] > max) {
            maxIndex = i;
            max = data[i];
        }
    }
    $("prediction-text").html("Predicting you draw <b>"+maxIndex+"</b> with <b>"+Math.trunc( max*100 )+"%</b> confidence")
}
	</script>
	
	
</html>